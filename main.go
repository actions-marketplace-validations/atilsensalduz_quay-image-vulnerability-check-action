package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
)

const (
	quayAPIURL = "https://quay.io/api/v1/"
)

type Tags struct {
	Tags          []Tag `json:"tags"`
	Page          int   `json:"page"`
	HasAdditional bool  `json:"has_additional"`
}

type Tag struct {
	Name           string `json:"name"`
	Reversion      bool   `json:"reversion"`
	StartTs        int    `json:"start_ts"`
	ManifestDigest string `json:"manifest_digest"`
	IsManifestList bool   `json:"is_manifest_list"`
	Size           int    `json:"size"`
	LastModified   string `json:"last_modified"`
}

type Security struct {
	Status interface{} `json:"status"`
	Data   struct {
		Layer struct {
			Name             string    `json:"Name"`
			ParentName       string    `json:"ParentName"`
			NamespaceName    string    `json:"NamespaceName"`
			IndexedByVersion int       `json:"IndexedByVersion"`
			Features         []Finding `json:"Features"`
		} `json:"layer"`
	} `json:"data"`
}

type Vulnerability struct {
	Severity      string `json:"Severity"`
	NamespaceName string `json:"NamespaceName"`
	Link          string `json:"Link"`
	FixedBy       string `json:"FixedBy"`
	Description   string `json:"Description"`
	Name          string `json:"Name"`
	Metadata      struct {
		UpdatedBy     string      `json:"UpdatedBy"`
		RepoName      interface{} `json:"RepoName"`
		RepoLink      interface{} `json:"RepoLink"`
		DistroName    string      `json:"DistroName"`
		DistroVersion string      `json:"DistroVersion"`
		Nvd           struct {
			CVSSv3 struct {
				Vectors string `json:"Vectors"`
				Score   any    `json:"Score"`
			} `json:"CVSSv3"`
		} `json:"NVD"`
	} `json:"Metadata"`
}

type Finding struct {
	Name            string          `json:"Name"`
	VersionFormat   string          `json:"VersionFormat"`
	NamespaceName   string          `json:"NamespaceName"`
	AddedBy         string          `json:"AddedBy"`
	Version         string          `json:"Version"`
	Vulnerabilities []Vulnerability `json:"Vulnerabilities"`
}

func main() {
	organization := os.Getenv("INPUT_ORGANIZATION")
	repository := os.Getenv("INPUT_REPOSITORY")
	imageTag := os.Getenv("INPUT_IMAGE_TAG")
	quayToken := os.Getenv("INPUT_QUAY_TOKEN")
	allowedSeverities := parseSeverities(os.Getenv("INPUT_SEVERITIES"))

	manifestDigest, err := getManifestDigestofImage(quayToken, organization, repository, imageTag)
	if err != nil {
		fmt.Printf("Error getting manifest digest: %v", err)
		os.Exit(1)
	}

	findings, err := getVulnerabilities(quayToken, organization, repository, manifestDigest, allowedSeverities)
	if err != nil {
		fmt.Printf("Error getting vulnerabilities: %v", err)
		os.Exit(1)
	}

	image := "quay.io/" + organization + "/" + repository + ":" + imageTag
	err = generateMarkdownReport(findings, image)
	if err != nil {
		fmt.Printf("Error generating Markdown report: %v", err)
		os.Exit(1)
	}
	// Check if vulnerabilities were found and set exit code
	if hasVulnerabilities(findings) {
		exitCode := getExitCode()
		os.Exit(exitCode)
	}
}

func getManifestDigestofImage(quayToken string, organization string, repository string, imageTag string) (string, error) {
	req, err := http.NewRequest("GET", quayAPIURL+"repository/"+organization+"/"+repository+"/tag/?onlyActiveTags=true&limit=1&filter_tag_name=eq:"+imageTag, nil)
	if err != nil {
		return "", err
	}

	req.Header.Set("Authorization", os.ExpandEnv("Bearer "+quayToken))
	req.Header.Set("Content-Type", "application/json")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	result := Tags{}
	if err := json.Unmarshal(body, &result); err != nil {
		return "", err
	}

	if len(result.Tags) > 0 {
		return result.Tags[0].ManifestDigest, nil
	}
	return "", nil
}

func getVulnerabilities(quayToken string, organization string, repository string, manifestDigest string, allowedSeverities []string) ([]Finding, error) {
	// Validate allowedSeverities
	validSeverities := map[string]bool{"Unknown": true, "Low": true, "Medium": true, "High": true, "Critical": true}
	for _, severity := range allowedSeverities {
		if !validSeverities[severity] {
			log.Fatalf("Invalid severity provided: %s. Allowed values are: Unknown, Low, Medium, High, Critical.", severity)
		}
	}

	req, err := http.NewRequest("GET", quayAPIURL+"repository/"+organization+"/"+repository+"/manifest/"+manifestDigest+"/security", nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", os.ExpandEnv("Bearer "+quayToken))
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	result := Security{}
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}

	var findings []Finding

	if len(result.Data.Layer.Features) > 0 {
		for _, features := range result.Data.Layer.Features {
			if len(features.Vulnerabilities) > 0 {
				// If allowedSeverities is empty, include all severities
				if len(allowedSeverities) == 0 {
					findings = append(findings, features)
				} else {
					// Filter vulnerabilities based on allowed severities
					filteredVulnerabilities := filterVulnerabilities(features.Vulnerabilities, allowedSeverities)
					if len(filteredVulnerabilities) > 0 {
						features.Vulnerabilities = filteredVulnerabilities
						findings = append(findings, features)
					}
				}
			}
		}
	}

	return findings, nil
}

func filterVulnerabilities(vulnerabilities []Vulnerability, allowedSeverities []string) []Vulnerability {
	var filteredVulnerabilities []Vulnerability

	for _, v := range vulnerabilities {
		for _, allowedSeverity := range allowedSeverities {
			if v.Severity == allowedSeverity {
				filteredVulnerabilities = append(filteredVulnerabilities, v)
				break
			}
		}
	}

	return filteredVulnerabilities
}

func generateMarkdownReport(findings []Finding, image string) error {
	file, err := os.Create("vulnerabilities_report.md")
	if err != nil {
		return err
	}
	defer file.Close()

	// Write header to the markdown file
	file.WriteString("### Image: " + image + "\n")
	file.WriteString("| Name | Severity | Link | DistroName | Score |\n")
	file.WriteString("|------|----------|------|------------|-------|\n")

	// Write findings to the markdown file
	for _, finding := range findings {
		for _, v := range finding.Vulnerabilities {
			line := fmt.Sprintf("| %s | %s | %s | %s | %v |\n",
				v.Name, v.Severity, v.Link, v.Metadata.DistroName, v.Metadata.Nvd.CVSSv3.Score)
			file.WriteString(line)
		}
	}

	fmt.Println("Markdown file 'vulnerabilities_report.md' generated successfully.")
	return nil
}

func parseSeverities(severities string) []string {
	if severities == "" {
		return nil
	}
	return strings.Split(severities, ",")
}

func hasVulnerabilities(findings []Finding) bool {
	for _, f := range findings {
		if len(f.Vulnerabilities) > 0 {
			return true
		}
	}
	return false
}

func getExitCode() int {
	exitCode := 0 // Default exit code
	if codeStr := os.Getenv("INPUT_EXIT_CODE"); codeStr != "" {
		parsedCode, err := strconv.Atoi(codeStr)
		if err == nil && (parsedCode == 0 || parsedCode == 1) {
			exitCode = parsedCode
		}
	}
	return exitCode
}
