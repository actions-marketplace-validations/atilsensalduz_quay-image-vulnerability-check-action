package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
)

const (
	quayAPIURL = "https://quay.io/api/v1/"
)

type Tags struct {
	Tags          []Tag `json:"tags"`
	Page          int   `json:"page"`
	HasAdditional bool  `json:"has_additional"`
}

type Tag struct {
	Name           string `json:"name"`
	Reversion      bool   `json:"reversion"`
	StartTs        int    `json:"start_ts"`
	ManifestDigest string `json:"manifest_digest"`
	IsManifestList bool   `json:"is_manifest_list"`
	Size           int    `json:"size"`
	LastModified   string `json:"last_modified"`
}

type Security struct {
	Status interface{} `json:"status"`
	Data   struct {
		Layer struct {
			Name             string    `json:"Name"`
			ParentName       string    `json:"ParentName"`
			NamespaceName    string    `json:"NamespaceName"`
			IndexedByVersion int       `json:"IndexedByVersion"`
			Features         []Finding `json:"Features"`
		} `json:"layer"`
	} `json:"data"`
}

type Finding struct {
	Name            string `json:"Name"`
	VersionFormat   string `json:"VersionFormat"`
	NamespaceName   string `json:"NamespaceName"`
	AddedBy         string `json:"AddedBy"`
	Version         string `json:"Version"`
	Vulnerabilities []struct {
		Severity      string `json:"Severity"`
		NamespaceName string `json:"NamespaceName"`
		Link          string `json:"Link"`
		FixedBy       string `json:"FixedBy"`
		Description   string `json:"Description"`
		Name          string `json:"Name"`
		Metadata      struct {
			UpdatedBy     string `json:"UpdatedBy"`
			RepoName      any    `json:"RepoName"`
			RepoLink      any    `json:"RepoLink"`
			DistroName    string `json:"DistroName"`
			DistroVersion string `json:"DistroVersion"`
			Nvd           struct {
				CVSSv3 struct {
					Vectors string `json:"Vectors"`
					Score   any    `json:"Score"`
				} `json:"CVSSv3"`
			} `json:"NVD"`
		} `json:"Metadata"`
	} `json:"Vulnerabilities"`
}

func main() {
	organization := os.Getenv("INPUT_ORGANIZATION")
	repository := os.Getenv("INPUT_REPOSITORY")
	imageTag := os.Getenv("INPUT_IMAGE_TAG")
	quayToken := os.Getenv("INPUT_QUAY_TOKEN")

	manifestDigest, err := getManifestDigestofImage(quayToken, organization, repository, imageTag)
	if err != nil {
		fmt.Printf("Error getting manifest digest: %v", err)
		os.Exit(1)
	}

	findings, err := getVulnerabilities(quayToken, organization, repository, manifestDigest)
	if err != nil {
		fmt.Printf("Error getting vulnerabilities: %v", err)
		os.Exit(1)
	}
	image := "quay.io/" + organization + "/" + repository + ":" + imageTag
	err = generateMarkdownReport(findings, image)
	if err != nil {
		fmt.Printf("Error generating Markdown report: %v", err)
		os.Exit(1)
	}
}

func getManifestDigestofImage(quayToken string, organization string, repository string, imageTag string) (string, error) {
	req, err := http.NewRequest("GET", quayAPIURL+"repository/"+organization+"/"+repository+"/tag/?onlyActiveTags=true&limit=1&filter_tag_name=eq:"+imageTag, nil)
	if err != nil {
		return "", err
	}

	req.Header.Set("Authorization", os.ExpandEnv("Bearer "+quayToken))
	req.Header.Set("Content-Type", "application/json")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	result := Tags{}
	if err := json.Unmarshal(body, &result); err != nil {
		return "", err
	}

	if len(result.Tags) > 0 {
		return result.Tags[0].ManifestDigest, nil
	}
	return "", nil
}

func getVulnerabilities(quayToken string, organization string, repository string, manifestDigest string) ([]Finding, error) {
	req, err := http.NewRequest("GET", quayAPIURL+"repository/"+organization+"/"+repository+"/manifest/"+manifestDigest+"/security", nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", os.ExpandEnv("Bearer "+quayToken))
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	result := Security{}
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, err
	}

	findings := make([]Finding, 0)
	if len(result.Data.Layer.Features) > 0 {
		for _, features := range result.Data.Layer.Features {
			if len(features.Vulnerabilities) > 0 {
				findings = append(findings, features)
			}
		}
		return findings, nil
	}

	return findings, nil
}

func generateMarkdownReport(findings []Finding, image string) error {
	file, err := os.Create("vulnerabilities_report.md")
	if err != nil {
		return err
	}
	defer file.Close()

	// Write header to the markdown file
	file.WriteString("### Image: " + image + "\n")
	file.WriteString("| Name | Severity | Link | DistroName | Score |\n")
	file.WriteString("|------|----------|------|------------|-------|\n")

	// Write findings to the markdown file
	for _, finding := range findings {
		for _, v := range finding.Vulnerabilities {
			line := fmt.Sprintf("| %s | %s | %s | %s | %v |\n",
				v.Name, v.Severity, v.Link, v.Metadata.DistroName, v.Metadata.Nvd.CVSSv3.Score)
			file.WriteString(line)
		}
	}

	fmt.Println("Markdown file 'vulnerabilities_report.md' generated successfully.")
	return nil
}
